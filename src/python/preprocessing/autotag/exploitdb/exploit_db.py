# This script reads in the exploit-db data and puts it into the format
# used in neo4j.

import json, codecs, os, csv, re, calendar

def date_to_epoch(date):
    date = re.split('[- :]',date)
    for x in range(0,len(date)):
        date[x] = int(date[x])
    date.append(0)
    date.append(0)
    date.append(0)
    date = tuple(date)
    date = calendar.timegm(date)
    return date

def get_exploit_db_data(filepath,filename):
    # Initialize a dictionary containing the information
    exploit_db_data = {}
    exploit_db_data["edges"] = []
    exploit_db_data["vertices"] = []
    var_names = []

    # Read in the data
    with open(filepath + '/' + filename) as csv_file:
        reader = csv.reader(csv_file, delimiter=',', quotechar='"')
        for row in reader:
            exploit = {}
            # Get the header row
            if row[0] == "id":          
                for var in row:
                    # Rename variables to what they are supposed to be in the output
                    if var == "id":
                        var = "ExploitdbID"
                    elif var == "file":
                        var = "filepath"
                    elif var == "type":
                        var = "_type"
                    elif var == "author":
                        var = "credit"
                    elif var == "type":
                        var == "ExploitdbType"
                    var_names.append(var)
            # Get the data
            else:
                for var in range(0,len(row)):
                    # Fix the encoding: convert from iso-8859-1 to utf-8 
                    # (there are special characters in the file that it couldn't decode)
                    row[var] = row[var].decode("iso-8859-1").encode("utf-8")
                    # Convert the date to epoch time
                    if var_names[var] == "date":
                        row[var] = date_to_epoch(row[var])
                    # Dictionary for each exploit
                    exploit[var_names[var]] = row[var]
                # Add the "_id" and "_type" keys to the dictionary
                exploit["_id"] = ""
                exploit["_type"] = "vertex"
                # Add this exploit to the set of nodes
                exploit_db_data["vertices"].append(exploit)
            
    # Output the data
    jsonify(exploit_db_data, filepath + "/" + "ExploitDB_data.graphson")

# Output the data in the proper format
def jsonify(obj, outFile):
    json.dump(obj, codecs.open(outFile, 'w', encoding='utf-8'),
    separators=(',',':'), sort_keys=True, indent=4)

def unjsonify(inFile):	
	obj_text = codecs.open(inFile, 'r', encoding='utf-8').read()
	obj = json.loads(obj_text)
	return obj

def add_edges(obj):
    edge_num = 0
    for i in range(0,len(obj["vertices"])):
        V = obj["vertices"][i]
        if "vulnerabilityID" in V.keys():
            obj["edges"].append({})
            obj["edges"][edge_num]["_id"]    = V["vulnerabilityID"] + "_to_" + V["bugtraqID"]
            obj["edges"][edge_num]["_inV"]   = V["vulnerabilityID"]
            obj["edges"][edge_num]["_label"] = "exploits"
            obj["edges"][edge_num]["_outV"]  = V["bugtraqID"]
            obj["edges"][edge_num]["_type"]  = "edge"
            obj["edges"][edge_num]["source"] = "ExploitDB"
            edge_num = edge_num + 1
        # Modify the name of the id nodes
        if "bugtraqID" in V.keys():
            V["_id"] = "BID:"+V["bugtraqID"]
            del V["bugtraqID"]
        # Change the date so it's a string
        V["date"] = str(V["date"])
    
    return obj

# file path where the data is stored and where the graphson file will be outputted
filepath = r'C:/Users/Corinne/Desktop/exploitdb'
filename = 'files.csv'
#get_exploit_db_data(filepath,filename)

# Add the edges to the existing graphson file
obj = unjsonify(filepath + "/" + "ExploitDB_data_IDs.graphson")
obj = add_edges(obj)
jsonify(obj, filepath + "/" + "ExploitDB_data_with_edges.graphson")
            
                
